% the script plots the data generated by survey_test.m

clear
clc
close all
%#ok<*UNRCH>
addpath('../utils')

plotmean = true;
plotindividual = false; % not compatible with plotting time
plotbootstrap = false;
plotmetrics = 1:4; % 1: SDR, 2: PEMO-Q ODG, 3: PEAQ ODG, 4: time

% bootstrap settings
alpha = 0.05;
draws = 1000;

% the audio signals to choose from
audio_files = { 'a08_violin', ...
                'a16_clarinet', ...
                'a18_bassoon', ...
                'a25_harp', ...
                'a35_glockenspiel', ...
                'a41_celesta', ...
                'a42_accordion', ...
                'a58_guitar_sarasate', ...
                'a60_piano_schubert', ...
                'a66_wind_ensemble_stravinsky' };
nofiles = length(audio_files);
           
%% load the data
filename = 'survey_test_rect_CR.mat';
load(filename)

%% reference algorithms
% available options
dec_algos = { 'consOMP', ...       % 1
              'aspade', ...        % 2
              'sspade_new', ...    % 3
              'CP', ...            % 4
              'DR', ...            % 5
              'SS_EW', ...         % 6
              'SS_PEW', ...        % 7
              'csl1', ...          % 8
              'pcsl1', ...         % 9
              'pwcsl1', ...        % 10
              'reweighted_CP', ... % 11
              'reweighted_DR', ... % 12
              'CP_parabola', ...   % 13
              'DR_parabola', ...   % 14
              'DL', ...            % 15
              'NMF'...            % 16
              };

% per each input SDR, choose the reference algorithms
% references = { [ 2, 3, 7 ], ... % 5 dB
%                [ 2, 7, 16 ], ... % 7 dB
%                [ 7, 13, 16 ], ... % 10 dB
%                [ 7, 13, 16 ], ... % 15 dB
%                };
           
references = 1:16;
           
% find the unique references
if iscell(references)
    unique_refs = unique([references{:}]);
else
    unique_refs = unique(references(:));
end

% save some useful numbers
num_inp = length(lambdaC);
num_glp = length(lambdaC);
num_dec = length(lambdaC)*length(lambdaS);
num_ref = length(unique_refs);
num_tot = num_inp + num_glp + num_dec + num_ref;

%% prepare the legend entries
legstr = cell(num_tot, 1);
counter = 0;

% inpainting
for i = 1:num_inp
    counter = counter + 1;
    legstr{counter} = ['inp, $\lambda_1$ = ', num2str(lambdaC(i))];
end

% glp
for i = 1:num_glp
    counter = counter + 1;
    legstr{counter} = ['glp, $\lambda_1$ = ', num2str(lambdaC(i))];
end

% declipping
for i = 1:length(lambdaS)
    for j = 1:length(lambdaC)
        counter = counter + 1;
        legstr{counter} = ['dec, $\lambda_1$ = ', num2str(lambdaC(j)), ', $\lambda_2$ = ', num2str(lambdaS(i))];
    end
end

% references
for i = 1:num_ref
    counter = counter + 1;
    legstr{counter} = strrep(dec_algos{unique_refs(i)}, '_', ' ');
end

%% prepare colors
mapcolors = turbo(num_ref);
mapcolors = [mapcolors(1:length(lambdaS)+2, :); mapcolors];
colors = zeros(num_tot, 3);
colors(num_inp + num_glp + num_dec + 1:end, :) = mapcolors(length(lambdaS)+3:end, :);
for i = 1:length(lambdaC)
    frac = i/length(lambdaC);

    % inpainting
    colors(i, :) = mapcolors(1, :)*frac + [1 1 1]*(1-frac);

    % glp
    colors(num_inp + i, :) = mapcolors(2, :)*frac + [1 1 1]*(1-frac);

    % declipping
    for j = 1:length(lambdaS)
        colors(num_inp + num_glp + (j-1)*length(lambdaC) + i, :) = mapcolors(2+j, :)*frac + [1 1 1]*(1-frac);
    end
end

%% plot mean from all signals
fcnt = 0; % figure counter
if plotmean
    for metric = plotmetrics

        % initialize plotdata (the mean values)
        plotdata = NaN(length(input_SDRs), num_tot);
        
        % initialize the bootstrap estimates
        plotlower = NaN(length(input_SDRs), num_tot);
        plotupper = NaN(length(input_SDRs), num_tot);

        % switch metric (what a surprise)
        switch metric
            case 1, field = 'SDRs';   reflabel = 'dSDR_all'; base = 0;
            case 2, field = 'PEMOQs'; reflabel = 'PEMO_Q';   base = -4;
            case 3, field = 'PEAQs';  reflabel = 'PEAQ';     base = -4;
            case 4, field = 'times';  reflabel = '';         base = 0.01;
        end

        % read the inpainting + glp + declipping data
        for method = 1:3

            % read the data
            switch method
                case 1, data = reconstructed(1).(field);
                case 2, data = reconstructed(3).(field);
                case 3, data = reconstructed(2).(field);
            end

            % compute dSDR (if applicable)
            if metric == 1
                if method == 3
                    data = data - repmat(clipped.SDRs, 1, 1, length(lambdaC), length(lambdaS));
                else
                    data = data - repmat(clipped.SDRs, 1, 1, length(lambdaC));
                end
            end

            % compute elapsed time per second of input audio (if applicable)
            if metric == 4
                for i = 1:length(audio_files)
                    [y, fs] = audioread(['../survey toolbox/Sounds/', audio_files{i}, '.wav']);
                    audiolen = length(y)/fs;
                    data(i, :, :) = data(i, :, :) / audiolen;
                end
            end

            % compute the mean values and the confidence intervals
            if plotbootstrap
                [data, lower, upper] = bootstrap_est(data, alpha=alpha, draws=draws);
            else
                [data, lower, upper] = bootstrap_est(data, alpha=alpha, draws=1);
            end
            data  = squeeze(data);
            lower = squeeze(lower);
            upper = squeeze(upper);

            % save to plotdata
            switch method
                case 1
                    for i = 1:num_inp
                        plotdata(:, i)  = data(:, i);
                        plotlower(:, i) = lower(:, i);
                        plotupper(:, i) = upper(:, i);
                    end
                case 2
                    for i = 1:num_glp
                        plotdata(:, num_inp + i)  = data(:, i);
                        plotlower(:, num_inp + i) = lower(:, i);
                        plotupper(:, num_inp + i) = upper(:, i);
                    end
                case 3
                    for i = 1:length(lambdaS)
                        for j = 1:length(lambdaC)
                            plotdata(:, num_inp + num_glp + (i-1)*length(lambdaC) + j)...
                                = data(:, j, i);
                            plotlower(:, num_inp + num_glp + (i-1)*length(lambdaC) + j)...
                                = lower(:, j, i);
                            plotupper(:, num_inp + num_glp + (i-1)*length(lambdaC) + j)...
                                = upper(:, j, i);
                        end
                    end
            end
        end

        % read the reference data
        for i = 1:length(input_SDRs)
            for j = 1:num_ref
                if metric == 4 % elapsed times
                    plotdata(i, num_inp + num_glp + num_dec + j)  = 0;
                    plotlower(i, num_inp + num_glp + num_dec + j) = 0;
                    plotupper(i, num_inp + num_glp + num_dec + j) = 0;
                else

                    if contains(filename, '_RR')
                        refdata = load(['../survey toolbox/Numerical_results/', reflabel, '_declippingResults_RR.mat']);
                        refdata = refdata.([reflabel, '_', dec_algos{unique_refs(j)}, '_RR']);
                    else
                        refdata = load(['../survey toolbox/Numerical_results/', reflabel, '_declippingResults.mat']);
                        refdata = refdata.([reflabel, '_', dec_algos{unique_refs(j)}]);
                    end
                    
                    [refdata, reflower, refupper] = bootstrap_est(refdata, alpha=alpha, draws=draws);
    
                    % the index for refdata needs to be shifted, because
                    % the input SDRs of 1 dB and 3 dB were omitted in the
                    % test
                    plotdata(i, num_inp + num_glp + num_dec + j)  = refdata(2+i);
                    plotlower(i, num_inp + num_glp + num_dec + j) = reflower(2+i);
                    plotupper(i, num_inp + num_glp + num_dec + j) = refupper(2+i);
                end
            end
        end

        % if metric == 4
        %     plotdata = plotdata(:, 1:(num_inp + num_glp + num_dec));
        %     plotlower = plotlower(:, 1:(num_inp + num_glp + num_dec));
        %     plotupper = plotupper(:, 1:(num_inp + num_glp + num_dec));
        % end

        % plot the bars
        fcnt = fcnt + 1;
        figs(fcnt) = figure('visible', 'off'); %#ok<SAGROW>
        b = bar(plotdata, 'BaseValue', base);

        % add shaded regions
        num_groups = 2 + length(lambdaS); % inp, glp, dec times the number of lambdaS values
        len_group = length(lambdaC);
        BarWidth = 0.9 * b(1).BarWidth / length(b);
        for i = 1:num_groups
            for j = 1:length(input_SDRs)
                x1 = b(1 + (i-1)*len_group).XEndPoints(j) - BarWidth/2;
                x2 = b(i*len_group).XEndPoints(j) + BarWidth/2;
                xregion(x1, x2,  'FaceColor', mapcolors(i, :), 'LineStyle', 'none', 'FaceAlpha', 0.2)
            end
        end
    
        % do the rest
        set(gca, 'xtick', 1:length(input_SDRs))
        set(gca, 'xticklabel', input_SDRs)
        set(gca, 'ygrid', 'on')
        set(gca, 'yminorgrid', 'on')
        xlabel('input SDR (dB)')
        xlim([0.5, 4.5])
        if metric == 1
            ylim([-1, 22])
        elseif metric == 4
            set(gca, 'yscale', 'log')
            ylim([1, 600])
        else
            ylim([-4, 0])
        end
        for i = 1:size(plotdata, 2)
            b(i).FaceColor = colors(i, :);
        end
                
        % plot the confidence intervals
        if plotbootstrap
            for i = 1:length(input_SDRs)
                for j = 1:length(b)
                    % x = b(j).XData(i) + b(j).XOffset;
                    x = b(j).XEndPoints(i);
                    line([x x], [plotlower(i, j) plotupper(i, j)], 'color', 'k')
                end
            end
        end

        % add legend
        legend(b, legstr, 'location', 'eastoutside')
        
        % add title
        switch metric
            case 1, title('$\Delta$SDR (dB)', 'mean from all signals')
            case 2, title('PEMO-Q ODG', 'mean from all signals')
            case 3, title('PEAQ ODG', 'mean from all signals')
            case 4, title('elapsed time per second of audio (s)', 'mean from all signals')
        end
    end
end

%% plot all the signals
if plotindividual
    
    % prepare the xticklabels (signal codes)
    ticklabels = cell(nofiles, 1);
    for i = 1:nofiles
        ticklabels{i} = strrep(audio_files{i}, '_', '\_');
    end
    
    for metric = plotmetrics
        for inputSDR = 1:length(input_SDRs)

            % initialize plotdata
            plotdata = NaN(nofiles + 2, num_tot);

            % switch metric (what a surprise)
            switch metric
                case 1, field = 'SDRs';   reflabel = 'dSDR_all';
                case 2, field = 'PEMOQs'; reflabel = 'PEMO_Q';
                case 3, field = 'PEAQs';  reflabel = 'PEAQ';
            end

            % read the inpainting + glp + declipping data
            for method = 1:3

                % read the data
                switch method
                    case 1, data = reconstructed(1).(field);
                    case 2, data = reconstructed(3).(field);
                    case 3, data = reconstructed(2).(field);
                end

                % compute dSDR (if applicable)
                if metric == 1
                    if method == 3
                        data = data - repmat(clipped.SDRs, 1, 1, length(lambdaC), length(lambdaS));
                    else
                        data = data - repmat(clipped.SDRs, 1, 1, length(lambdaC));
                    end
                end

                % squeeze the data
                data = squeeze(data(:, inputSDR, :, :));

                % save to plotdata
                switch method
                    case 1
                        for i = 1:num_inp
                            plotdata(1 : nofiles, i) = data(:, i);
                            plotdata(nofiles + 1, i) = mean(data(:, i), 'omitnan');
                            plotdata(nofiles + 2, i) = median(data(:, i), 'omitnan');
                        end
                    case 2
                        for i = 1:num_glp
                            plotdata(1 : nofiles, num_inp + i) = data(:, i);
                            plotdata(nofiles + 1, num_inp + i) = mean(data(:, i), 'omitnan');
                            plotdata(nofiles + 2, num_inp + i) = median(data(:, i), 'omitnan');
                        end
                    case 3
                        for i = 1:length(lambdaS)
                            for j = 1:length(lambdaC)
                                plotdata(1 : nofiles, num_inp + num_glp + (i-1)*length(lambdaC) + j) = data(:, j, i);
                                plotdata(nofiles + 1, num_inp + num_glp + (i-1)*length(lambdaC) + j) = mean(data(:, j, i), 'omitnan');
                                plotdata(nofiles + 2, num_inp + num_glp + (i-1)*length(lambdaC) + j) = median(data(:, j, i), 'omitnan');
                            end
                        end
                end
            end
            
            % read the reference data
            for j = 1:length(unique_refs)
                refdata = load(['../survey toolbox/Numerical_results/', reflabel, '_declippingResults.mat']);
                refdata = refdata.([reflabel, '_', dec_algos{unique_refs(j)}]);

                % the index for refdata needs to be shifted, because
                % the input SDRs of 1 dB and 3 dB were omitted in the
                % test
                plotdata(1 : nofiles, num_inp + num_glp + num_dec + j) = refdata(:, 2+inputSDR);
                plotdata(nofiles + 1, num_inp + num_glp + num_dec + j) = mean(refdata(:, 2+inputSDR), 1);
                plotdata(nofiles + 2, num_inp + num_glp + num_dec + j) = median(refdata(:, 2+inputSDR), 1);
            end

            % finally plot it
            fcnt = fcnt + 1;
            figs(fcnt) = figure('visible', 'off');
            b = bar(plotdata, 'BaseValue', base);
            legend(legstr, 'location', 'eastoutside')
            set(gca, 'xtick', 1:nofiles+2)
            set(gca, 'xticklabel', [ticklabels; {'mean'; 'median'}])
            set(gca, 'ygrid', 'on')
            set(gca, 'yminorgrid', 'on')
            xlabel('audio files')
            if metric == 1
                ylim([-1, Inf])
            else
                ylim([-Inf, 0])
            end
            for i = 1:size(plotdata, 2)
                b(i).FaceColor = colors(i, :);
            end
            switch metric
                case 1, title('$\Delta$SDR (dB)', ['input SDR ', num2str(input_SDRs(inputSDR)), ' dB'])
                case 2, title('PEMO-Q ODG', ['input SDR ', num2str(input_SDRs(inputSDR)), ' dB'])
                case 3, title('PEAQ ODG', ['input SDR ', num2str(input_SDRs(inputSDR)), ' dB'])
            end
        end
    end
end

%% make the figures visible
for f = figs
    set(f, 'WindowStyle', 'docked', 'Visible', 'on')
end