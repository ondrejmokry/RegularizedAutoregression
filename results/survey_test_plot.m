% the script plots the data generated by survey_test.m

clear
clc
close all
%#ok<*UNRCH>
addpath('../utils')

plotmean = true;
plotindividual = false; % not compatible with plotting time
plotbootstrap = false;
plotwilcoxon = false;
plotmetrics = 1:4;
% 1: SDR
% 2: PEMO-Q ODG  (only for music)
% 3: PEAQ ODG    (only for music)
% 4: time        (only for music)
% 5: STOI        (only for speech)
% 6: ViSQOL MOS  (only for speech)
% 7: ViSQOL NSIM (only for speech)

% prepare title
titles = { ...
    '$\Delta$SDR (dB)', ...
    'PEMO-Q ODG', ...
    'PEAQ ODG', ...
    'elapsed time per second of audio (s)', ...
    'STOI', ...
    'ViSQOL MOS', ...
    'ViSQOL NSIM' ...
};

% bootstrap settings
alpha = 0.05;
draws = 1000;
           
%% load the data
filename = 'survey_test_rect.mat';
% filename = 'speech_test.mat';
load(filename)
nofiles = length(audio_files);

%% reference algorithms
% available options
dec_algos = { ...
    'consOMP', ...       % 1
    'aspade', ...        % 2
    'sspade_new', ...    % 3
    'CP', ...            % 4
    'DR', ...            % 5
    'SS_EW', ...         % 6
    'SS_PEW', ...        % 7
    'csl1', ...          % 8
    'pcsl1', ...         % 9
    'pwcsl1', ...        % 10
    'reweighted_CP', ... % 11
    'reweighted_DR', ... % 12
    'CP_parabola', ...   % 13
    'DR_parabola', ...   % 14
    'DL', ...            % 15
    'NMF'...             % 16
};

dec_names = { ...
    'C-OMP', ...         % 1
    'A-SPADE', ...       % 2
    'S-SPADE', ...       % 3
    'CP', ...            % 4
    'DR', ...            % 5
    'SS EW', ...         % 6
    'SS PEW', ...        % 7
    'CSL1', ...          % 8
    'PCSL1', ...         % 9
    'PWCSL1', ...        % 10
    'reweighted CP', ... % 11
    'reweighted DR', ... % 12
    'CP parabola', ...   % 13
    'DR parabola', ...   % 14
    'DL', ...            % 15
    'NMF' ...            % 16
};

% per each input SDR, choose the reference algorithms
% references = { [ 2, 3, 7 ], ... % 5 dB
%                [ 2, 7, 16 ], ... % 7 dB
%                [ 7, 13, 16 ], ... % 10 dB
%                [ 7, 13, 16 ], ... % 15 dB
%                };

if contains(filename, 'speech')
    references = [2, 7, 8];
else
    references = 1:16;
end
           
% find the unique references
if iscell(references)
    unique_refs = unique([references{:}]);
else
    unique_refs = unique(references(:));
end

% save some useful numbers
num_inp = length(lambdaC);
num_glp = length(lambdaC);
num_dec = length(lambdaC)*length(lambdaS);
num_ref = length(unique_refs);
num_tot = num_inp + num_glp + num_dec + num_ref;

%% prepare the legend entries
legstr = cell(num_tot, 1);
counter = 0;

% inpainting
for i = 1:num_inp
    counter = counter + 1;
    legstr{counter} = ['inp., $\lambda_\mathrm{C}$ = ', lambda2str(lambdaC(i))];
end

% glp
for i = 1:num_glp
    counter = counter + 1;
    legstr{counter} = ['GLP, $\lambda_\mathrm{C}$ = ', lambda2str(lambdaC(i))];
end

% declipping
for i = 1:length(lambdaS)
    for j = 1:length(lambdaC)
        counter = counter + 1;
        legstr{counter} = ['dec., $\lambda_\mathrm{C}$ = ', lambda2str(lambdaC(j)), ', $\lambda_\mathrm{S}$ = ', lambda2str(lambdaS(i))];
    end
end

% references
for i = 1:num_ref
    counter = counter + 1;
    legstr{counter} = dec_names{unique_refs(i)};
end

%% prepare colors
mapcolors = turbo(max(num_ref, length(lambdaS)+2));
mapcolors = [mapcolors(1:length(lambdaS)+2, :); mapcolors(1:num_ref, :)];
colors = zeros(num_tot, 3);
if num_ref > 0
    colors(num_inp + num_glp + num_dec + 1:end, :) = mapcolors(length(lambdaS)+3:end, :);
end
for i = 1:length(lambdaC)
    frac = i/length(lambdaC);

    % inpainting
    colors(i, :) = mapcolors(1, :)*frac + [1 1 1]*(1-frac);

    % glp
    colors(num_inp + i, :) = mapcolors(2, :)*frac + [1 1 1]*(1-frac);

    % declipping
    for j = 1:length(lambdaS)
        colors(num_inp + num_glp + (j-1)*length(lambdaC) + i, :) = mapcolors(2+j, :)*frac + [1 1 1]*(1-frac);
    end
end

if contains(filename, 'speech') 
    load('../utils/barcolors.mat')
end

%% plot mean from all signals
fcnt = 0; % figure counter
if plotmean
    for metric = plotmetrics

        % initialize plotdata (the mean values)
        plotdata = NaN(length(audio_files), length(input_SDRs), num_tot);
        
        % switch metric (what a surprise)
         switch metric
            case 1, field = 'SDRs';   reflabel = 'dSDR_all'; base = 0;     ylims = [-1, Inf];
            case 2, field = 'PEMOQs'; reflabel = 'PEMO_Q';   base = -4;    ylims = [-4, 0];
            case 3, field = 'PEAQs';  reflabel = 'PEAQ';     base = -4;    ylims = [-4, 0];
            case 4, field = 'times';  reflabel = '';         base = 0.01;  ylims = [1, 600];
            case 5, field = 'STOIs';  reflabel = 'STOI';     base = 0;     ylims = [0, 1];
            case 6, field = 'MOSs';   reflabel = 'MOS';      base = 1;     ylims = [1, 5];
            case 7, field = 'NSIMs';  reflabel = 'NSIM';     base = 0;     ylims = [0, 1];
        end

        % read the inpainting + glp + declipping data
        for method = 1:3

            % read the data
            switch method
                case 1, data = reconstructed(1).(field);
                case 2, data = reconstructed(3).(field);
                case 3, data = reconstructed(2).(field);
            end

            % compute dSDR (if applicable)
            if metric == 1
                if method == 3
                    data = data - repmat(clipped.SDRs, 1, 1, length(lambdaC), length(lambdaS));
                else
                    data = data - repmat(clipped.SDRs, 1, 1, length(lambdaC));
                end
            end

            % compute elapsed time per second of input audio (if applicable)
            if metric == 4
                for i = 1:length(audio_files)
                    [y, fs] = audioread(['../survey toolbox/Sounds/', audio_files{i}, '.wav']);
                    audiolen = length(y)/fs;
                    data(i, :, :) = data(i, :, :) / audiolen;
                end
            end

            % save to plotdata
            switch method
                case 1
                    for i = 1:num_inp
                        plotdata(:, :, i)  = data(:, :, i);
                    end
                case 2
                    for i = 1:num_glp
                        plotdata(:, :, num_inp + i)  = data(:, :, i);
                    end
                case 3
                    for i = 1:length(lambdaS)
                        for j = 1:length(lambdaC)
                            plotdata(:, :, num_inp + num_glp + (i-1)*length(lambdaC) + j)...
                                = data(:, :, j, i);
                        end
                    end
            end
        end

        % read the reference data
        for i = 1:length(input_SDRs)
            for j = 1:num_ref
                if metric == 4 % elapsed times
                    plotdata(:, i, num_inp + num_glp + num_dec + j)  = 0;
                else

                    if contains(filename, '_RR')
                        refdata = load(['../survey toolbox/Numerical_results/', reflabel, '_declippingResults_RR.mat']);
                        refdata = refdata.([reflabel, '_', dec_algos{unique_refs(j)}, '_RR']);
                    elseif contains(filename, 'speech')
                        refdata = load(['../survey toolbox/Numerical_results/', reflabel, '_declippingResults_speech.mat']);
                        refdata = refdata.([reflabel, '_', dec_algos{unique_refs(j)}]);
                    else
                        refdata = load(['../survey toolbox/Numerical_results/', reflabel, '_declippingResults.mat']);
                        refdata = refdata.([reflabel, '_', dec_algos{unique_refs(j)}]);
                    end
                        
                    
                    if contains(filename, 'speech')
                        plotdata(:, i, num_inp + num_glp + num_dec + j)  = refdata(:, i);
                    else
                        % the index for refdata needs to be shifted, 
                        % because the input SDRs of 1 dB and 3 dB were 
                        % omitted in the test
                        plotdata(:, i, num_inp + num_glp + num_dec + j)  = refdata(:, 2+i);
                    end
                end
            end
        end

        if plotwilcoxon 
            % [p, h] = signrank(x,y) returns the p-value of a paired, two-sided test 
            % for the null hypothesis that x – y comes from a distribution with zero 
            % median.
            % h = 1 indicates a rejection of the null hypothesis, and h = 0 indicates
            % a failure to reject the null hypothesis at the 5% significance level.
            % In words, simplified:
            % p < 0.05 → h = 1 → null hypothesis rejected → x > y
            P = zeros(length(input_SDRs), num_tot, num_tot);
            H = zeros(length(input_SDRs), num_tot, num_tot);
            for inputSDR = 1:length(input_SDRs)
                for i = 1:num_tot
                    for j = 1:num_tot
                        [P(inputSDR, i, j), H(inputSDR, i, j)] = signrank(plotdata(:, inputSDR, i), plotdata(:, inputSDR, j), tail='right');
                    end
                end
            end
            
            % custom colormap
            numcolors = 256;
            cmin = 0.001;
            cmax = 1;
            [~, bpt] = min(abs(logspace(log10(cmin), log10(cmax), numcolors)-0.05));
            bpt = min(max(bpt, 1), numcolors);
            rest = numcolors - bpt;
            niceblue = [0.27691, 0.44145, 0.91328];
            nicered = [0.83926, 0.20654, 0.02305];
            % r = [(0:bpt-1)'/max(bpt-1, 1); ones(rest, 1)];
            % g = [(0:bpt-1)'/max(bpt-1, 1); ((rest-1):-1:0)'/max(rest-1, 1)];
            % b = [ones(bpt, 1); ((rest-1):-1:0)'/max(rest-1, 1)];
            % custommap = [r g b];
            custommap = [ ...
                % blue part (below the breakpoint)
                0.1 + (0.5 + 0.4*(0:bpt-1)'/max(bpt-1, 1)) .* niceblue;
                % red part (above the breakpoint)
                0.1 + (0.5 + 0.4*(0:(rest-1))'/max(rest-1, 1)) .* nicered;
            ];
            for inputSDR = 1:length(input_SDRs)
                fcnt = fcnt + 1;
                figs(fcnt) = figure( ...
                    'visible', 'off', ...
                    'Name', [lower(field(1:end-1)), '_', num2str(input_SDRs(inputSDR), '%02d'), '_dB']); %#ok<SAGROW>
                imagedata = squeeze(log10(P(inputSDR,:,:)));
                imagesc(imagedata)
                axis square
                clim([log10(cmin), log10(cmax)])
                colormap(gca, custommap)
                cbr = colorbar;
                cbr.Label.String = 'p-value';
                cbr.Label.Interpreter = 'latex';
                cbr.Ticks = sort([log10(cmin):log10(cmax), log10(0.05)]);
                cbr.TickLabels = {'0.001', '0.01', '0.05', '0.1', '1'};
                set(gca, 'XTick', 1:num_tot, 'YTick', 1:num_tot, 'XTickLabel', legstr, 'YTickLabel', legstr)
                title(titles{metric}, sprintf('input SDR %d dB', input_SDRs(inputSDR)), 'Interpreter', 'latex')
    
                % nexttile
                % imagesc(squeeze(H(inputSDR,:,:)));
                % axis square
                % colormap(gca, 'gray')
                % cbr = colorbar;
                % cbr.Label.String = 'null hypothesis rejection';
                % cbr.Label.Interpreter = 'latex';
                % cbr.Ticks = [0, 1];
                % cbr.TickLabels = {'false', 'true'};
                % set(gca, 'XTick', 1:num_tot, 'YTick', 1:num_tot, 'XTickLabel', legstr, 'YTickLabel', legstr)
            end
        end

        % saving custom stuff with matlab2tikz:
        % (1) make sure that the following variables are set properly:
        %     (a) cmin (in our case, the actual limit are log10(cmin))
        %     (b) cmax (in our case, the actual limit are log10(cmax))
        %     (c) imagedata
        %     (d) custommap
        % (2) save as usual:
        %     matlab2tikz("filename.tex")
        % (3) change manually the colormap, use the following string:
        %     cmapstring = "";
        %     for i = 0:255
        %         cmapstring = cmapstring + sprintf("rgb(%dpt)=(%.4f,%.4f,%.4f); ", i, custommap(i+1,1), custommap(i+1,2), custommap(i+1,3));
        %     end
        % (4) replace the PNG with the following file:
        %     imwrite(gray2ind(mat2gray(imagedata,[cmin cmax]), 256), custommap, "filename.png")

        % compute the mean values and the confidence intervals
        if plotbootstrap
            [plotdata, plotlower, plotupper] = bootstrap_est(plotdata, alpha=alpha, draws=draws);
        else
            [plotdata, plotlower, plotupper] = bootstrap_est(plotdata, alpha=alpha, draws=1);
        end

        % if metric == 4
        %     plotdata = plotdata(:, 1:(num_inp + num_glp + num_dec));
        %     plotlower = plotlower(:, 1:(num_inp + num_glp + num_dec));
        %     plotupper = plotupper(:, 1:(num_inp + num_glp + num_dec));
        % end

        % plot the bars
        fcnt = fcnt + 1;
        figs(fcnt) = figure( ...
            'visible', 'off', ...
            'Name', ['sloupecky_', lower(field(1:end-1))]);
        b = bar(plotdata, 'BaseValue', base);

        % add shaded regions
        num_groups = 2 + length(lambdaS); % inp, glp, dec times the number of lambdaS values
        len_group = length(lambdaC);
        BarWidth = 0.9 * b(1).BarWidth / length(b);
        for i = 1:num_groups
            for j = 1:length(input_SDRs)
                x1 = b(1 + (i-1)*len_group).XEndPoints(j) - BarWidth/2;
                x2 = b(i*len_group).XEndPoints(j) + BarWidth/2;
                xregion(x1, x2,  'FaceColor', mapcolors(i, :), 'LineStyle', 'none', 'FaceAlpha', 0.2)
            end
        end
    
        % do the rest
        set(gca, 'xtick', 1:length(input_SDRs))
        set(gca, 'xticklabel', input_SDRs)
        set(gca, 'ygrid', 'on')
        set(gca, 'yminorgrid', 'on')
        xlabel('input SDR (dB)')
        xlim([0.5, 4.5])
        ylim(ylims)
        if metric == 4
            set(gca, 'yscale', 'log')
        end
        for i = 1:size(plotdata, 2)
            if i <= num_inp + num_glp + num_dec
                b(i).FaceColor = colors(i, :);
            else
                shift = num_inp + num_glp + num_dec;
                b(i).FaceColor = colors(shift + unique_refs(i-shift), :);
            end
            
            % check the colors
            % fprintf('%.5f  ', b(i).FaceColor)
            % disp(legstr{i})
        end
                
        % plot the confidence intervals
        if plotbootstrap
            for i = 1:length(input_SDRs)
                for j = 1:length(b)
                    % x = b(j).XData(i) + b(j).XOffset;
                    x = b(j).XEndPoints(i);
                    line([x x], [plotlower(i, j) plotupper(i, j)], 'color', 'k')
                end
            end
        end

        % add legend
        legend(b, legstr, 'location', 'eastoutside')
        
        % add title
        title(titles{metric}, 'mean from all signals')
    end
end

%% plot all the signals
if plotindividual
    
    % prepare the xticklabels (signal codes)
    ticklabels = cell(nofiles, 1);
    for i = 1:nofiles
        ticklabels{i} = strrep(audio_files{i}, '_', '\_');
    end
    
    for metric = plotmetrics
        if metric == 4
            continue
        end
        for inputSDR = 1:length(input_SDRs)

            % initialize plotdata
            plotdata = NaN(nofiles + 2, num_tot);

            % switch metric (what a surprise)
            switch metric
                case 1, field = 'SDRs';   reflabel = 'dSDR_all'; base = 0;     ylims = [-1, Inf];
                case 2, field = 'PEMOQs'; reflabel = 'PEMO_Q';   base = -4;    ylims = [-4, 0];
                case 3, field = 'PEAQs';  reflabel = 'PEAQ';     base = -4;    ylims = [-4, 0];
                case 4, field = 'times';  reflabel = '';         base = 0.01;  ylims = [-Inf, Inf];
                case 5, field = 'STOIs';  reflabel = 'STOI';     base = 0;     ylims = [0, 1];
                case 6, field = 'MOSs';   reflabel = 'MOS';      base = 1;     ylims = [1, 5];
                case 7, field = 'NSIMs';  reflabel = 'NSIM';     base = 0;     ylims = [0, 1];
            end

            % read the inpainting + glp + declipping data
            for method = 1:3

                % read the data
                switch method
                    case 1, data = reconstructed(1).(field);
                    case 2, data = reconstructed(3).(field);
                    case 3, data = reconstructed(2).(field);
                end

                % compute dSDR (if applicable)
                if metric == 1
                    if method == 3
                        data = data - repmat(clipped.SDRs, 1, 1, length(lambdaC), length(lambdaS));
                    else
                        data = data - repmat(clipped.SDRs, 1, 1, length(lambdaC));
                    end
                end

                % squeeze the data
                data = squeeze(data(:, inputSDR, :, :));

                % save to plotdata
                switch method
                    case 1
                        for i = 1:num_inp
                            plotdata(1 : nofiles, i) = data(:, i);
                            plotdata(nofiles + 1, i) = mean(data(:, i), 'omitnan');
                            plotdata(nofiles + 2, i) = median(data(:, i), 'omitnan');
                        end
                    case 2
                        for i = 1:num_glp
                            plotdata(1 : nofiles, num_inp + i) = data(:, i);
                            plotdata(nofiles + 1, num_inp + i) = mean(data(:, i), 'omitnan');
                            plotdata(nofiles + 2, num_inp + i) = median(data(:, i), 'omitnan');
                        end
                    case 3
                        for i = 1:length(lambdaS)
                            for j = 1:length(lambdaC)
                                plotdata(1 : nofiles, num_inp + num_glp + (i-1)*length(lambdaC) + j) = data(:, j, i);
                                plotdata(nofiles + 1, num_inp + num_glp + (i-1)*length(lambdaC) + j) = mean(data(:, j, i), 'omitnan');
                                plotdata(nofiles + 2, num_inp + num_glp + (i-1)*length(lambdaC) + j) = median(data(:, j, i), 'omitnan');
                            end
                        end
                end
            end
            
            % read the reference data
            for j = 1:length(unique_refs)
                refdata = load(['../survey toolbox/Numerical_results/', reflabel, '_declippingResults.mat']);
                refdata = refdata.([reflabel, '_', dec_algos{unique_refs(j)}]);

                % the index for refdata needs to be shifted, because
                % the input SDRs of 1 dB and 3 dB were omitted in the
                % test
                plotdata(1 : nofiles, num_inp + num_glp + num_dec + j) = refdata(:, 2+inputSDR);
                plotdata(nofiles + 1, num_inp + num_glp + num_dec + j) = mean(refdata(:, 2+inputSDR), 1);
                plotdata(nofiles + 2, num_inp + num_glp + num_dec + j) = median(refdata(:, 2+inputSDR), 1);
            end

            % finally plot it
            fcnt = fcnt + 1;
            figs(fcnt) = figure('visible', 'off');
            b = bar(plotdata, 'BaseValue', base);
            legend(legstr, 'location', 'eastoutside')
            set(gca, 'xtick', 1:nofiles+2)
            set(gca, 'xticklabel', [ticklabels; {'mean'; 'median'}])
            set(gca, 'ygrid', 'on')
            set(gca, 'yminorgrid', 'on')
            xlabel('audio files')
            ylim(ylims)
            for i = 1:size(plotdata, 2)
                b(i).FaceColor = colors(i, :);
            end
            switch metric
                case 1, title('$\Delta$SDR (dB)', ['input SDR ', num2str(input_SDRs(inputSDR)), ' dB'])
                case 2, title('PEMO-Q ODG', ['input SDR ', num2str(input_SDRs(inputSDR)), ' dB'])
                case 3, title('PEAQ ODG', ['input SDR ', num2str(input_SDRs(inputSDR)), ' dB'])
            end
        end
    end
end

%% make the figures visible
for f = figs
    set(f, 'WindowStyle', 'docked', 'Visible', 'on')
end

%% custom num2str
function str = lambda2str(lambda)

    switch lambda
        case 0
            str = '0';
        case Inf
            str = '$\infty$';
        otherwise
            exponent = log10(lambda);
            if exponent == 1
                str = '10';
            else
                str = ['$10^{', num2str(exponent), '}$'];
            end
    end

end