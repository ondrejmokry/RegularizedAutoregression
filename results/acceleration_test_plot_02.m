% the script plots the data generated by acceleration_test.m
%
% a figure is plotted per each combination of input SDR and metric (SDR, 
% PEMO-Q ODG, PEAQ ODG)
%
% each figure contains tiles based on method (inpainting, consistent
% declipping, inconsistent declipping and GLP) and Ilker's acceleration
%
% the individual plots compare the gains in terms of performance and time

clear
clc
close all

addpath('..\utils')

% metric indexes, 1: SDR, 2: PEMOQ ODG, 3: PEAQ ODG
metrics = 1;

% prepare the strings for variations
strs = {'none', 'coef. sub-problem', 'sig. sub-problem', 'coef. and sig. sub-problems'};

% prepare the colors for variants
colors = [  0      0.4470 0.7410;... % 10 ACS iterations, 1000 DRA iterations
            0.8500 0.3250 0.0980;... % 10 ACS iterations, progressive DRA iterations
            0.9290 0.6940 0.1250;... % 5 ACS iterations, 1000 DRA iterations, linesearch
            0.4940 0.1840 0.5560;... % 5 ACS iterations, 1000 DRA iterations, coef. extrapolation
            0.4660 0.6740 0.1880;... % 5 ACS iterations, 1000 DRA iterations, sig. extrapolation
            0.3010 0.7450 0.9330 ];  % 5 ACS iterations, 1000 DRA iterations, coef. and sig. extrapolation

% load the file
load('acceleration_test_rect_01.mat')

for metric = metrics
    switch metric
        case 1, field = 'SDRs';   str = 'SDR (dB)';
        case 2, field = 'PEMOQs'; str = 'PEMO-Q ODG';
        case 3, field = 'PEAQs';  str = 'PEAQ ODG';
    end
    for j = 3 % j = 1:length(input_SDRs)
                
        % create the figure
        fig = figure('visible', 'off');
        tls = tiledlayout(4, 4, 'TileIndexing', 'columnmajor');
        
        % initialize the array for references and labels
        baselinedata = NaN(length(ps)*length(ws), 4);
        baselinetime = NaN(length(ps)*length(ws), 4);
        pwlabels = cell(length(ps)*length(ws), 1);
        
        % iterate
        a = 0; % algo counter
        for algo = [1 3 7 11] % indexes based on the struct array reconstructed
            a = a + 1;
            switch algo
                case 1, variations = 2; sbplts = [1 2]; % inpainting
                case 3, variations = 4; sbplts = [5 6 9 10]; % consistent declipping
                case 7, variations = 4; sbplts = [7 8 11 12]; % inconsistent declipping
                case 11, variations = 2; sbplts = [3 4]; % GLP
            end
            for variation = 1:variations

                % create the tile
                nexttile(tls, sbplts(variation))
                
                % initialize the array for results
                timedata = NaN(length(ps)*length(ws), 6);
                perfdata = NaN(length(ps)*length(ws), 6);
                
                pw = 0;
                for k = 1:length(ps)   
                    for l = 1:length(ws)
                        pw = pw + 1;
                        timedata(pw, :) = -log10(...
                            mean(...
                            squeeze(reconstructed(algo+variation-1).times(:, j, k, l, :))...
                            ./ squeeze(reconstructed(algo).times(:, j, k, l, 1)), ...
                            'omitnan'));
                        perfdata(pw, :) = mean(...
                            squeeze(reconstructed(algo+variation-1).(field)(:, j, k, l, :))...
                            - squeeze(reconstructed(algo).(field)(:, j, k, l, 1)), ...
                            'omitnan');
                        if variation == 1
                            pwlabels{pw} = sprintf('p = %d, w = %d', ps(k), ws(l));
                            baselinedata(pw, a) = mean(...
                                reconstructed(algo).(field)(:, j, k, l, 1), ...
                            'omitnan');
                            baselinetime(pw, a) = mean(...
                                reconstructed(algo).times(:, j, k, l, 1), ...
                            'omitnan');
                        end
                    end
                end
                
                data = NaN(6, 6, 2);
                data(:, :, 1) = timedata;
                data(:, :, 2) = perfdata;
                
                % plot the performance and time gain
                [h, order] = plotBarPlusDiff(data, ...
                    'grouplabels', pwlabels, ...
                    'legend', false, ...
                    'newfigure', false, ...
                    'colors', colors);
                if ~exist('lgd', 'var')
                    lgd = legend(h(order(1:6)), {...
                        '10 ACS iterations, 1000 DRA iterations', ...
                        '10 ACS iterations, progressive DRA iterations', ...
                        '5 ACS iterations, 1000 DRA iterations, linesearch', ...
                        '5 ACS iterations, 1000 DRA iterations, coef. extrapolation', ...
                        '5 ACS iterations, 1000 DRA iterations, sig. extrapolation', ...
                        '5 ACS iterations, 1000 DRA iterations, coef. and sig. extrapolation' ...
                        });
                    lgd.Layout.Tile = 14;
                end
                box on
                
                % title
                title(sprintf('%s (%s)', reconstructed(algo).algorithm, strs{variation}))
                
            end
                       
        end
        
        % set y axis limits
        ymin = Inf;
        ymax = -Inf;
        for ax = 1:length(tls.Children)
            if strcmp(tls.Children(ax).Tag, 'legend')
                continue
            end
            ymin = min(ymin, tls.Children(ax).YLim(1));
            ymax = max(ymax, tls.Children(ax).YLim(2));
        end
        ymin = max(ymin, -1); % to simplify comparison of _rect data with the old data
        for ax = 1:length(tls.Children)
            if strcmp(tls.Children(ax).Tag, 'legend')
                continue
            end
            tls.Children(ax).YLim = [ymin, ymax];
        end
        
        % add tile with y axis description
        nexttile(tls, 13)
        size = 12;
        line([0 1], [0 0], 'color', 'k')
        text(0.20, 0.60, ...
            '$$\uparrow$$ time gain (darker shade)', ...
            'FontSize', size)
        text(0.23, 0.35, ...
            'log10 ((baseline time) / (accelerated time))', ...
            'FontSize', size-2)
        text(0.23, 0.15, ...
            'positive value = acceleration works', ...
            'FontSize', size-4)
        text(0.23, -0.15, ...
            'negative value = performance decreases', ...
            'FontSize', size-4)
        text(0.23, -0.35, ...
            ['(accelerated ', str, ') -- (baseline ', str, ')'], ...
            'FontSize', size-2)
        text(0.20, -0.60, ...
            '$$\downarrow$$ performance loss (lighter shade)', ...
            'FontSize', size)
        set(gca, 'visible', 'off')
                
        % add baseline times
        figure
        tls_baseline = tiledlayout(2, 1);
        nexttile
        newcolors = gray(6);
        newcolors = newcolors(2:end-1, :);
        b = bar(baselinetime);
        for i = 1:4
            b(i).FaceColor = newcolors(i, :);
        end
        legend(...
            reconstructed(1).algorithm, ...
            reconstructed(3).algorithm, ...
            reconstructed(7).algorithm, ...
            reconstructed(11).algorithm)
        set(gca, 'XTickMode', 'manual')
        set(gca, 'XTick', 1:length(pwlabels))
        set(gca, 'XTickLabelMode', 'manual')
        set(gca, 'XTickLabel', pwlabels)
        % set(gca, 'YScale', 'log')
        ylabel('time (s)')
        title('elapsed times of the baseline algorithms')
        box on
        
        % add baseline performances
        nexttile
        b = bar(baselinedata);
        for i = 1:4
            b(i).FaceColor = newcolors(i, :);
        end
        legend(...
            reconstructed(1).algorithm, ...
            reconstructed(3).algorithm, ...
            reconstructed(7).algorithm, ...
            reconstructed(11).algorithm)
        set(gca, 'XTickMode', 'manual')
        set(gca, 'XTick', 1:length(pwlabels))
        set(gca, 'XTickLabelMode', 'manual')
        set(gca, 'XTickLabel', pwlabels)
        ylabel(str)
        title('performance of the baseline algorithms')
        box on
        
        % title the whole figure
        title(tls, sprintf('%s\ninput SDR %d dB', str, input_SDRs(j)))
        title(tls_baseline, sprintf('%s\ninput SDR %d dB', str, input_SDRs(j)))

        % make the figure full-screen
        set(fig, 'WindowState', 'maximized', 'visible', 'on')
        
    end
end