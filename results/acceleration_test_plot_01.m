% the script plots the data generated by acceleration_test.m
%
% a figure is plotted per each combination of metric (SDR, PEMO-Q ODG, PEAQ
% ODG), AR model order (p) and window length (w)
%
% each figure contains 16 subplots based on method (inpainting, consistent
% declipping, inconsistent declipping and GLP) and input SDR

clear
clc
close all
%#ok<*UNRCH>
%#ok<*SAGROW>

% compare old and new data?
compare = false;

% metric indexes, 1: SDR, 2: PEMOQ ODG, 3: PEAQ ODG
metrics = 1;

% prepare the shapes for FFT-acceleration
shapes = {'o', 'x', '+', 'd'};
% 1: none
% 2: coef. sub-problem
% 3: sig. sub-problem
% 4: coef. and sig. sub-problems

% prepare the colors for variants
colors = [  0      0.4470 0.7410;... % 10 ACS iterations, 1000 DRA iterations
            0.8500 0.3250 0.0980;... % 10 ACS iterations, progressive DRA iterations
            0.9290 0.6940 0.1250;... % 5 ACS iterations, 1000 DRA iterations, linesearch
            0.4940 0.1840 0.5560;... % 5 ACS iterations, 1000 DRA iterations, coef. extrapolation
            0.4660 0.6740 0.1880;... % 5 ACS iterations, 1000 DRA iterations, sig. extrapolation
            0.3010 0.7450 0.9330 ];  % 5 ACS iterations, 1000 DRA iterations, coef. and sig. extrapolation

% load the file
load('acceleration_test_rect_01.mat') % needed for metadata and for the plots if not comparing
if compare
    % older data
    % old = load('acceleration_test_01.mat', 'reconstructed');
    old = load('acceleration_test_rect_02.mat', 'reconstructed');
    old = old.reconstructed;
    
    % newer data
    new = load('acceleration_test_rect_01.mat', 'reconstructed');
    new = new.reconstructed;

    % rewrite reconstructed struct
    fs = fields(reconstructed);
    fs = fs(2:end);
    for i = 1:length(reconstructed)
        for j = 1:length(fs)
            reconstructed(i).(fs{j}) = new(i).(fs{j}) - old(i).(fs{j});
        end

        % find negative times
        [a, b, c, d, e] = ind2sub(size(reconstructed(i).times), find(reconstructed(i).times < 0));
        if ~isempty(a)
            fprintf('Negative times for algorithm %s:\n', algos{i})
        end
        for k = 1:length(a)
            fprintf('   (%d) ', k)
            fprintf('file: %s, input SDR: %2d dB, p: %4d, w: %4d, acc. variant: %d, time diff.: %5.1f s, ', ...
                audio_files{a(k)}(1:3), input_SDRs(b(k)), ps(c(k)), ws(d(k)), e(k), reconstructed(i).times(a(k), b(k), c(k), d(k), e(k)))
            fprintf('old SDR / diff: %6.2f /%6.2f dB, ', ...
                old(i).SDRs(a(k), b(k), c(k), d(k), e(k)), ...
                reconstructed(i).SDRs(a(k), b(k), c(k), d(k), e(k)))
            fprintf('old PEMO-Q / diff: %5.2f /%5.2f, ', ...
                old(i).PEMOQs(a(k), b(k), c(k), d(k), e(k)), ...
                reconstructed(i).PEMOQs(a(k), b(k), c(k), d(k), e(k)))
            fprintf('old PEAQ / diff: %5.2f /%5.2f\n', ...
                old(i).PEAQs(a(k), b(k), c(k), d(k), e(k)), ...
                reconstructed(i).PEAQs(a(k), b(k), c(k), d(k), e(k)))
        end
        
        % get rid of negative times
        reconstructed(i).times(reconstructed(i).times <= 0) = NaN;
    end
    clear new old
end

for metric = metrics
    switch metric
        case 1, field = 'SDRs';   str = 'SDR (dB)';
        case 2, field = 'PEMOQs'; str = 'PEMO-Q ODG';
        case 3, field = 'PEAQs';  str = 'PEAQ ODG';
    end
    for k = 1 % k = 1:length(ps)   
        for l = 3 % l = 1:length(ws)
            
            % create the figure
            figure('visible', 'off')
            % tls = tiledlayout(length(input_SDRs), 4);
            tls = tiledlayout(1, 4);
            
            % iterate over the subplots
            for j = 3 % j = 1:length(input_SDRs)
                
                % compute the future axes limits
                mintimedec  =  Inf;
                maxtimedec  = -Inf;
                minvaluedec =  Inf;
                maxvaluedec = -Inf;
                mintimeinp  =  Inf;
                maxtimeinp  = -Inf;
                minvalueinp =  Inf;
                maxvalueinp = -Inf;
                for algo = [1 3 7 11] % indexes based on the struct array reconstructed
                    switch algo
                        case 1, variations = 2; % inpainting
                        case 3, variations = 4; % consistent declipping
                        case 7, variations = 4; % inconsistent declipping
                        case 11, variations = 2; % GLP
                    end
                    for variation = 1:variations
                        for m = 1:6
                            if algo == 3 || algo == 7
                                mintimedec  = min(mintimedec, min(reconstructed(algo+variation-1).times(:, j, k, l, m)));
                                maxtimedec  = max(maxtimedec, max(reconstructed(algo+variation-1).times(:, j, k, l, m)));
                                minvaluedec = min(minvaluedec, min(reconstructed(algo+variation-1).(field)(:, j, k, l, m)));
                                maxvaluedec = max(maxvaluedec, max(reconstructed(algo+variation-1).(field)(:, j, k, l, m)));
                            else
                                mintimeinp  = min(mintimeinp, min(reconstructed(algo+variation-1).times(:, j, k, l, m)));
                                maxtimeinp  = max(maxtimeinp, max(reconstructed(algo+variation-1).times(:, j, k, l, m)));
                                minvalueinp = min(minvalueinp, min(reconstructed(algo+variation-1).(field)(:, j, k, l, m)));
                                maxvalueinp = max(maxvalueinp, max(reconstructed(algo+variation-1).(field)(:, j, k, l, m)));
                            end
                        end
                    end
                end
                
                % plot
                for algo = [1 3 7 11] % indexes based on the struct array reconstructed
                    switch algo
                        case 1, variations = 2; % inpainting
                        case 3, variations = 4; % consistent declipping
                        case 7, variations = 4; % inconsistent declipping
                        case 11, variations = 2; % GLP
                    end
                    
                    % create the plot
                    nexttile(tls)
                    hold on
                    
                    % iterate over the variations (distinguished by shape)
                    for variation = 1:variations
                        
                        % iterate over the variants (distinguished by color)
                        for m = 1:6
                            
                            % scatter the time and metric per each signal
                            scatter(...
                                reconstructed(algo+variation-1).times(:, j, k, l, m), ...
                                reconstructed(algo+variation-1).(field)(:, j, k, l, m), ...
                                20, ...
                                colors(m, :), ...
                                shapes{variation}, ...
                                'MarkerEdgeAlpha', 0.3)
                            
                            % add the mean
                            scatter(...
                                mean(reconstructed(algo+variation-1).times(:, j, k, l, m), 'omitnan'), ...
                                mean(reconstructed(algo+variation-1).(field)(:, j, k, l, m), 'omitnan'), ...
                                45, ...
                                colors(m, :), ...
                                shapes{variation})
                            
                        end
                    end

                    % create legend only once
                    if ~exist('lgd', 'var')
                        % variations
                        h(1) = scatter(NaN, NaN, 45, [0, 0, 0], shapes{1}, 'DisplayName', 'none');
                        h(2) = scatter(NaN, NaN, 45, [0, 0, 0], shapes{2}, 'DisplayName', 'coef. sub-problem');
                        h(3) = scatter(NaN, NaN, 45, [0, 0, 0], shapes{3}, 'DisplayName', 'sig. sub-problem');
                        h(4) = scatter(NaN, NaN, 45, [0, 0, 0], shapes{4}, 'DisplayName', 'coef. and sig. sub-problems');
                        
                        % variants
                        h(5) = scatter(NaN, NaN, 45, colors(1, :), shapes{1}, 'DisplayName', '10 ACS iterations, 1000 DRA iterations');
                        h(6) = scatter(NaN, NaN, 45, colors(2, :), shapes{1}, 'DisplayName', '10 ACS iterations, progressive DRA iterations');
                        h(7) = scatter(NaN, NaN, 45, colors(3, :), shapes{1}, 'DisplayName', '5 ACS iterations, 1000 DRA iterations, linesearch');
                        h(8) = scatter(NaN, NaN, 45, colors(4, :), shapes{1}, 'DisplayName', '5 ACS iterations, 1000 DRA iterations, coef. extrapolation');
                        h(9) = scatter(NaN, NaN, 45, colors(5, :), shapes{1}, 'DisplayName', '5 ACS iterations, 1000 DRA iterations, sig. extrapolation');
                        h(10) = scatter(NaN, NaN, 45, colors(6, :), shapes{1}, 'DisplayName', '5 ACS iterations, 1000 DRA iterations, coef. and sig. extrapolation');

                        lgd = legend(h);
                        lgd.Layout.Tile = 'east';
                    end

                    % title the plot
                    title(sprintf('%s\n input SDR %d dB', reconstructed(algo).algorithm, input_SDRs(j)))
                    
                    % make the time axis logarithmic
                    set(gca, 'XScale', 'log')
                    
                    % add axis labels
                    xlabel('time (s)')
                    ylabel(str)
                    
                    % set axes limits
                    if algo == 3 || algo == 7
                        valuedif = maxvaluedec - minvaluedec;
                        xlim([0.9*mintimedec, 1.1*maxtimedec]);
                        ylim(minvaluedec + [-0.1, 1.1]*valuedif);
                    else
                        valuedif = maxvalueinp - minvalueinp;
                        xlim([0.9*mintimeinp, 1.1*maxtimeinp]);
                        ylim(minvalueinp + [-0.1, 1.1]*valuedif);
                    end

                    % add box and grid
                    box on
                    grid on
                end
            end
            
            % title the whole figure
            if compare
                title(tls, sprintf('difference in the recomputed experiment, %s\np = %d, w = %d', str, ps(k), ws(l)))
            else
                title(tls, sprintf('%s\np = %d, w = %d', str, ps(k), ws(l)))
            end

            % make the figure full-screen
            set(gcf, 'WindowState', 'maximized', 'visible', 'on')
        end
    end
end